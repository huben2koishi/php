<?php
namespace A;
use B\D, C\E as F;

// 函数调用
foo();      // 首先尝试调用 A 中的函数foo(), 再尝试调用全局函数 "foo"
\foo();     // 调用全局空间函数 foo()
my\foo();   // 调用 A\my 中函数 foo()
F();        // 首先尝试调用 A 中的函数 F() 再尝试调用全局函数 F()

// 类引用
new B();    // 创建 A 中定义的类 B 的一个对象, 如果未找到, 则尝试自动装载类 A\B
new D();    // 创建 B 中定义的类 D 的一个对象, 如果未找到，则尝试自动装载类 B\D
new F();    // 创建 C 中定义的类 E 的一个对象, 如果未找到, 则尝试自动装载类 C\E
new \B();   // 创建全局空间中的类 B 的一个对象, 如果未发现, 则尝试自动装载类 B
new \D();   // 创建全局空间中的类 D 的一个对象, 如果未发现, 则尝试自动装载类 D
new \F();   // 创建全局空间中的类 F 的一个对象, 如果未发现, 则尝试自动装载类 F

// 调用另一个命名空间中的静态方法或命名空间函数
B\foo();    // 调用 A\B 中函数 foo()
B::foo();   // 调用 A 中定义的类 B 的 foo() 方法, 如果未找到类 A\B, 则尝试自动装载类 A\B
D::foo();   // 调用 B 中定义的类 D 的 foo() 方法, 如果未找到类 B\D, 则尝试自动装载类 B\D
\B\foo();   // 调用 B 中的函数 foo()
\B::foo();  // 调用全局空间中的类 B 的 foo 方法, 如果类 B 未找到, 则尝试自动装载类 B

// 当前命名空间中的静态方法或函数
A\B::foo();   // 调用 A\A 中定义的类 B 的 foo() 方法, 如果类 A\A\B 未找到, 则尝试自动装载类 A\A\B
\A\B::foo();  // 调用 A 中定义的类 B 的 foo 方法, 如果类 A\B 未找到, 则尝试自动装载类 A\B